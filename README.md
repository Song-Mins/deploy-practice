## 📚 Spring Boot 애플리케이션을 EC2 서버에 배포하는 다양한 방법 실습
이때까지 다양한 방법으로 Spring Boot 애플리케이션을 EC2 서버에 배포해보았는데 이러한 배포방법들을 정리하고자 한다.   
대략적인 내용은 다음과 같다.
1. Spring Boot 애플리케이션을 EC2 서버에 배포하는 3가지 방법을 직접 해보고, 수동으로 진행했던 배포 프로세스를 CI/CD 도구인 github-actions를 활용해 자동화
2. 위처럼 배포할 때, 리버스 프록시로 가장 많이 사용되는 nginx를 활용하여 Blue-Green 방식의 무중단 배포 및 HTTPS 설정, IP별 요청 제한 등 세부 설정 적용
3. MySQL, Redis, Nginx 실행 및 .jar 파일 실행할 때, 직접 설치하여 실행하는 방법과 Docker 컨테이너를 이용하는 방법을 모두 실습

</br></br>

## ✏️ 배포 방법
이 프로젝트에서 실습할 배포 방법은 아래와 같다.
1. 로컬에서 빌드한 .jar 파일을 ec2 서버에 전송하여 실행
2. ec2 서버에서 프로젝트 클론하여 빌드 후 실행
3. 로컬에서 빌드한 도커 이미지를 ec2 서버에서 pull 받아 컨테이너 실행

</br>

## ✏️ 브랜치 종류 및 설명
여기서는 각 브랜치별 배포 방법의 특징을 간략히 설명한다.   
각 브랜치별 배포 방법에 대한 구체적인 구현 내용 및 명령어는 해당 브랜치의 README 파일을 참고하자.
### transfer-jar
- 로컬에서 빌드한 .jar 파일을 ec2 서버에 전송하여 실행

- 특징
  - 단순히 빌드된 .jar 파일을 서버로 전송하고 실행하면 되기 때문에 간단하고 빠르게 애플리케이션 실행 가능
  - 서버에 직접 Java 및 MySQL, Redis, Nginx 를 설치해야하고 로컬의 버전과 일치해야됨

### clone-project
- ec2 서버에서 프로젝트 클론하여 빌드 후 실행

- 특징
  - 서버에 프로젝트 코드가 존재하여 바로 확인가능 하고 Git 을 활용해 원하는 시점의 코드로 롤백할 수 있음
  - 서버 자원이 애플리케이션 빌드 작업에 소모되므로 본래의 요청 처리나 운영에 영향을 줄 수 있음
  - 서버에 직접 Java 및 MySQL, Redis, Nginx 를 설치해야하고 로컬의 버전과 일치해야됨

### pull-image
- 로컬에서 빌드한 도커 이미지를 ec2 서버에서 pull 받아 컨테이너 실행

- 특징
  - 컨테이너 기반 배포로 인해 실행 환경이 일관되며, 환경 차이로 인한 문제를 최소화
  - 서버에는 Docker Engine 만 설치하면 됨

### transfer-jar-cicd
- transfer-jar 브랜치의 배포방법을 자동화

### clone-project-cicd
- clone-project 브랜치의 배포방법을 자동화

### pull-image-cicd
- pull-image 브랜치의 배포방법을 자동화

</br>

## ✏️ MySQL, Redis, Nginx 서버 실행 방법
현재 배포할려는 Spring Boot 애플리케이션을 실행하려면 MySQL, Redis 서버가 실행중 이여야 한다.    
또한, 여러 설정을 하기 위해 리버스 프록시인 Nginx 서버가 실행중 이여한다.  
이를 실행하는 방법에는 아래와 같이 대표적으로 3가지 방법이 있다.

1. AWS 서비스 (RDS, ElastiCache, Application Load Balancer) 이용
- 자동 백업, 확장성, 고가용성 등의 기능을 통해 사용자는 애플리케이션 개발 및 운영에만 집중 가능
- 사용량에 따라 비용이 발생

2. EC2 서버에 직접 설치 및 실행
- 추가적인 기술 없이 바로 설치 및 실행 가능
- 백업, 모니터링, 확장 등을 직접 관리 해야됨

3. 도커 이미지를 사용하는 방법
- 컨테이너화된 환경을 제공하므로 개발 환경과 운영 환경의 차이로 인한 문제를 최소화 가능
- =백업, 모니터링, 확장 등을 직접 관리 해야됨

1번 방법은 나중에 AWS 서비스들에 대해 공부할때 해볼것이며,
이 프로젝트 에서는 transfer-jar, clone-build 브랜치 에서는 2번, pull-image 브랜치에서는 3번 방법을 해볼것이다.

</br>

## ✏️ 접근 제한
클라인언트는 nginx 에만 접근 가능하고 Mysql, Redis 서버는 Spring Boot 에서만 접근 가능하도록 제한

1. 도커 컨테이너를 통해  nginx, Mysql, Redis, Spring Boot 를 실행하는 경우
- 클라인언트가 nginx 에만 접근가능하게 하기위해 ec2 의 보안그룹 설정에 80 포트만 열어뒀음
- 4개의 컨테이너가 실행되는 커스텀 네트워크에 설정을 해주고, nginx 컨테이너만 포트포워딩을 해줌
- 커스텀 네트워크 사용이유

2. ec2 서버에 mysql, redis, nginx 를 직접 설치하여 실행하고  jar 파일을 실행하는 경우
- 클라인언트가 nginx 에만 접근가능하게 하기위해 ec2 의 보안그룹 설정에 80 포트만 열어뒀음
- ec2 인스턴스 내부 네트워크 설정으로 접근 제한함

</br>

## ✏️ 기존 실행중인 애플리케이션 종료
기존 실행중인 애플리케이션이 처리하는 요청이 있는경우 이 요청을 처리하고 종료돼야됨
- Spring Boot 애플리케이션의 application.yaml 파일에 SIGTERM 종료 요청을 정상정으로 처리할수 있도록 graceful shutdown 설정추가
- jar 파일을 실행하는 경우는 kill -15 명령어,  Spring Boot 컨테이너를 실행하는 경우는 docker rm —time 명령어로 SIGTERM 종료 요청 보냄
- docker rm —time 명령어는 옵션에 주어진 시간동안 종료가 안되면 자동으로 SIGKILL 종료 요청을 보냄
- 하지만, 예기치못한 상황이 있을수 있기 때문에 30초 이후에 종료 여부를 확인한후 종료가 안됐으면 각각  kill -9,  docker kill 명령어로 SIGKILL 요청 보냄

</br>

## ✏️ 도커 이미지 저장소 - pull-image 브랜치
로컬에서 도커 이미지를 푸시하고 EC2 서버에서 풀하기 위해서 도커 이미지 저장소가 필요하다.  
대표적인 도커 이미지 저장소는 아래와 같이 3가지가 있다.

1. Docker Hub
- Docker의 기본 이미지 저장소로, Docker CLI 와 완벽하게 통합
- 커뮤니티에 공유된 수많은 공용 이미지에 접근 가능

2. GitHub Container Registry (GHCR)
- GitHub와 통합된 컨테이너 이미지 저장소로, GitHub Actions 와 원활하게 동작
- GitHub Actions에서 바로 사용 가능하여 CI/CD 파이프라인 설정이 간단
- 소스 코드와 이미지를 한 곳에서 관리 가능

3. Amazon Elastic Container Registry (ECR)
- AWS 서비스로, EC2, ECS, EKS와 같은 AWS 서비스와 긴밀히 통합
- IAM 을 통해 세밀한 권한 관리 가능
- 보안 및 인증 관리가 뛰어남

</br>

## ✏️ 도커 이미지 태그 - pull-image 브랜치
mysql, redis 이미지 태그는 V0.0. 형식으로 하였고,spring 이미지 태그는 커밋의 sha 값으로 함
- Mysql, Redis 이미지는 특별한 상황이 아니면 업데이트 될일이 없기때문에 버전을 태그로 하여 어떤 버전일때의 이미지인지 쉽게 알수 있게함
- Spring 이미지는 프로젝트 코드의 변경이 생기면 생성되므로 버전이 아닌 커밋의 sha 값을 태그로 하여 어떤 커밋일때 생성된 이미지인지 쉽게 찾을수 있게 함

</br>

## ✏️ 기존 실행중인 애플리케이션(.jar 파일 실행) 종료 - transfer-jar, clone-build 브랜치
]pgrep -f .jar 명령어로 실행중인 명령어의

1. 문제 상황
- 로컬 환경에서는 pgrep 명령어가 정상 동작하였지만, GitHub Actions 환경에서는 실행 중인 .jar 파일이 없는데도 2개의 pid가 출력됨
- 또한, 실행할때마다 출력되는 2개의 pid 값이 매번 변경됨
- 로컬에서 sudo를 사용하여 pgrep 명령어를 실행하면 GitHub Actions 환경과 동일한 문제가 발생함

2. 문제 원인
- pgrep 명령어는 전체 커맨드라인에서 지정한 패턴을 검색함
- EC2 서버 부팅 시 백그라운드에서 실행되는 여러 Java 기반 애플리케이션 때문에, 의도하지 않은 프로세스가 검색되어 출력됨
- 백그라운드에서 실행 중인 다른 Java 애플리케이션들은 pid가 동적으로 할당되어 pgrep 명령어를 실행할 때마다 pid 값이 달라짐
- root 사용자로 실행되었기 때문에 sudo를 붙여야만 pid가 출력되며, appleboy/ssh-actions 액션 사용 시 ec2-user 옵션을 주더라도 pgrep은 전체 사용자의 프로세스를 검색함

3. 문제 해결
- pgrep 시 .jar 파일을 실행한 정확한 명령어로 필터링하는 방법을 고려했으나, GitHub Actions에서는 정규식 인식 문제로 실패하였음
- 따라서, pgrep 명령어 대신 아래 두 가지 방식을 고민함
- 8080, 8081 포트 중에서 실행 중인 프로세스가 있는지 확인한 후, 해당 프로세스가 .jar 파일로 실행된 애플리케이션인지 점검
- .jar 파일 실행 시 실행된 프로세스의 pid를 포트 번호에 대응하는 pid 파일에 저장하여, 2개의 pid 파일 중에서 pid 값이 있는지 확인하고 실제 프로세스 상태인지 점검
- 실행한 애플리케이션의 pid 값을 저장했다가 이 pid 값으로 종료하는 것이 직관적이라 생각해 처음엔 이방법으로 하였지만, 각 포트에 대한 pid 파일을 2개 사용하게 되면서 코드의 가독성이 안좋아져 포트를 활용하는 방법으로 변경함

**기존 실행중인 애플리케이션 종료**

- **기존 실행중인 애플리케이션이 처리하는 요청이 있는경우 이 요청을 처리하고 종료돼야됨**
  - Spring Boot 애플리케이션의 application.yaml 파일에 SIGTERM 종료 요청을 정상정으로 처리할수 있도록 graceful shutdown 설정추가
  - jar 파일을 실행하는 경우는 kill -15 명령어,  Spring Boot 컨테이너를 실행하는 경우는 docker rm —time 명령어로 SIGTERM 종료 요청 보냄
  - docker rm —time 명령어는 옵션에 주어진 시간동안 종료가 안되면 자동으로 SIGKILL 종료 요청을 보냄
  - 하지만, 예기치못한 상황이 있을수 있기 때문에 30초 이후에 종료 여부를 확인한후 종료가 안됐으면 각각  kill -9,  docker kill 명령어로 SIGKILL 요청 보냄

</br>
